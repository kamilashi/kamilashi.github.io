{% highlight cpp %}

//for every interactable from the pre-filtererd array: 

float expandedRadius = pInteractibleComponent->interactorSensorSphereData.sensorSphereRadius * ((isThisLastAvailableInteractionInRange && pInteractorComponent->pSetupData->interactionSensorPointData.canExpand) ? pInteractibleComponent->interactorSensorSphereData.inRangeSphereExpandFactor : 1.0f);

if (isPointInsideSphere(&isInRange, &currentSquareDistance, pInteractibleComponent->interactorSensorSphereData.worldSpacePosition, expandedRadius, interactorPoint)
  && (pInteractorComponent->exclusiveInteraction == tix::ecs::InvalidEntityId || isExclusiveInteraction(*pInteractibleComponent, *pInteractorComponent))
  && MultistableUtility::isUnlocked(pMultistableComponent)
  && !pInteractorComponent->isInteractionLocked
  && !InteractibleUtility::isInteractedWith(*pInteractibleComponent))
{
  bool foundValidTransition = false;
  size_t validTransitionIdx = 0u;
  for (size_t iTransition = 0u; iTransition < transitionLibrary.transitions.getSize(); iTransition ++)
  {
    if( areTransitionRequirementsMet(pInteractorMovementState, *pInteractibleComponent, pMultistableComponent, *pQuickTimeEventStorage, transitionLibrary.transitions[iTransition], interactorEntityId)
      &&(isStaticInteractor
        || // if we are past this point - our interactor is someone with a movement state component (player / horse / NPC)
        (isMovementStateCorrect(*pInteractorMovementState, horsemanStorage, interactorEntityId)
        && isInteractibleWithinViewAndReachable(&currentAngleDiff, pData->interactibleFacingDirectionCache[interactibleIdx], transitionLibrary.transitions[iTransition], pFacingStorage->getComponentReadOnly(interactorEntityId), interactorPositionComponent, interactiblePositionComponent, pInteractibleComponent->interactorViewAngleRange, pInteractibleComponent->maxHeightDifference)))
        && isInteractorTypeRequirementMet(&potentialInteraction, *pInteractorComponent, playerData, transitionLibrary.transitions[iTransition], interactorEntityId))
      {
        foundValidTransition = true;
        validTransitionIdx = iTransition;

        if (transitionLibrary.transitions[iTransition].autoTriggerOption != AutoTrigger_Never && !autoTriggerInteractions.isFull())
        {
          InteractibleUtility::AvailableInteraction autoTriggerInteraction(pInteractibleComponent->interactibleEntityId, iTransition, transitionLibrary.transitions[iTransition].autoTriggerOption, pInteractibleComponent);
          autoTriggerInteractions.pushBack(autoTriggerInteraction);
        }
      }
  }

  bool hasHigherPrio = hasSmallerAngleOrHigherPrio(currentAngleDiff, smallestAngleDiff, static_cast<int> (pInteractibleComponent->interactionPriority), highestPriority);
  if (foundValidTransition && (isStaticInteractor || hasHigherPrio))
  {
    overwriteAvailableInteraction(pInteractorComponent, &highestPriority, &smallestAngleDiff, currentAngleDiff, *pInteractibleComponent, validTransitionIdx, transitionLibrary.transitions[validTransitionIdx]);
  }
  else if (potentialInteraction.type != PotentialInteractionType::PotentialInteractionType_Count && !isStaticInteractor && !foundValidTransition && hasHigherPrio) // transition would have been valid if not for the failed requirements check;
  {
    overwritePotentialInteraction(pInteractorComponent, potentialInteraction);
  }
}
{% endhighlight %}